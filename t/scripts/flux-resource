#!/usr/bin/env python

import argparse
import errno
import yaml
import flux

def heading ():
    return '{:20} {:20} {:20} {:20}'.format ('JOBID', 'STATUS',
                                             'AT', 'OVERHEAD (Secs)')

def body (jobid, status, at, overhead):
    t = "Now" if at == 0 else str (at)
    o = str (overhead)
    return '{:20} {:20} {:20} {:20}'.format (str (jobid), status, t, o)

def width ():
    return 20 + 20 + 20 + 20

"""
    Class to interface with the resource module with RPC
"""
class ResourceModuleInterface:
    def __init__ (self):
        self.f = flux.Flux ()

    def rpc_next_jobid (self):
        resp = self.f.rpc ("resource.next_jobid").get ()
        return resp['jobid']

    def rpc_allocate (self, jobid, jobspec_str):
        payload = {'cmd' : 'allocate', 'jobid' : jobid, 'jobspec' : jobspec_str}
        return self.f.rpc ("resource.match", payload).get ()

    def rpc_allocate_with_satisfiability (self, jobid, jobspec_str):
        payload = {'cmd' : 'allocate_with_satisfiability',
                   'jobid' : jobid, 'jobspec' : jobspec_str}
        return self.f.rpc ("resource.match", payload).get ()

    def rpc_reserve (self, jobid, jobspec_str):
        payload = {'cmd' : 'allocate_orelse_reserve',
                   'jobid' : jobid, 'jobspec' : jobspec_str}
        return self.f.rpc ("resource.match", payload).get ()

    def rpc_info (self, jobid):
        payload = {'jobid' : jobid}
        return self.f.rpc ("resource.info", payload).get ()

    def rpc_stat (self):
        return self.f.rpc ("resource.stat").get ()

    def rpc_cancel (self, jobid):
        payload = {'jobid' : jobid}
        return self.f.rpc ("resource.cancel", payload).get ()

"""
    Action for match allocate sub-command
"""
def match_alloc_action (args):
    with open (args.jobspec, 'r') as stream:
        jobspec_str = yaml.dump (yaml.load (stream))
        r = ResourceModuleInterface ()
        resp = r.rpc_allocate (r.rpc_next_jobid (), jobspec_str)
        print heading ()
        print body (resp['jobid'], resp['status'], resp['at'], resp['overhead'])
        print ("=" * width ())
        print "MATCHED RESOURCES:"
        print resp['R']

"""
    Action for match allocate_with_satisfiability sub-command
"""
def match_alloc_sat_action (args):
    with open (args.jobspec, 'r') as stream:
        jobspec_str = yaml.dump (yaml.load (stream))
        r = ResourceModuleInterface ()
        resp = r.rpc_allocate_with_satisfiability (r.rpc_next_jobid (),
                                                   jobspec_str)
        print heading ()
        print body (resp['jobid'], resp['status'], resp['at'], resp['overhead'])
        print ("=" * width ())
        print "MATCHED RESOURCES:"
        print resp['R']

"""
    Action for match allocate_orelse_reserve sub-command
"""
def match_reserve_action (args):
    with open (args.jobspec, 'r') as stream:
        jobspec_str = yaml.dump (yaml.load (stream))
        r = ResourceModuleInterface ()
        resp = r.rpc_reserve (r.rpc_next_jobid (), jobspec_str)
        print heading ()
        print body (resp['jobid'], resp['status'], resp['at'], resp['overhead'])
        print ("=" * width ())
        print "MATCHED RESOURCES:"
        print resp['R']

"""
    Action for cancel sub-command
"""
def cancel_action (args):
    r = ResourceModuleInterface ()
    jobid = args.jobid
    resp = r.rpc_cancel (jobid)

"""
    Action for info sub-command
"""
def info_action (args):
    r = ResourceModuleInterface ()
    jobid = args.jobid
    resp = r.rpc_info (jobid)
    print heading ()
    print body (resp['jobid'], resp['status'], resp['at'], resp['overhead'])

"""
    Action for stat sub-command
"""
def stat_action (args):
    r = ResourceModuleInterface ()
    resp = r.rpc_stat ()
    print "Num. of Vertices: ", resp['V']
    print "Num. of Edges: ", resp['E']
    print "Graph Load Time: ", resp['load-time'], "Secs"
    print "Num. of Jobs Matched: ", resp['njobs']
    print "Min. Match Time: ", resp['min-match'], "Secs"
    print "Max. Match Time: ", resp['max-match'], "Secs"
    print "Avg. Match Time: ", resp['avg-match'], "Secs"

"""
    Main entry point
"""
def main ():
    #
    # Main command arguments/options
    #
    desc = 'Front-end command for resource '\
           'module for testing. Provide 4 sub-commands. '\
           'For sub-command usage, '\
           '%(prog)s <sub-command> --help'
    parser = argparse.ArgumentParser (description=desc)
    parser.add_argument ('-v', '--verbose', action='store_true',
                         help='be verbose')

    #
    # Add subparser for the top-level sub-commands
    #
    subpar = parser.add_subparsers (title='Available Commands',
                                    description='Valid commands',
                                    help='Additional help')
    mstr = "Find the best matching resources for a jobspec"
    istr = "Print info on a single job"
    sstr = "Print overall performance statistics"
    cstr = "Cancel an allocated or reserved job"
    parser_m = subpar.add_parser ('match', help=mstr, description=mstr)
    parser_i = subpar.add_parser ('info', help=istr, description=istr)
    parser_s = subpar.add_parser ('stat', help=sstr, description=sstr)
    parser_c = subpar.add_parser ('cancel', help=cstr, description=cstr)

    #
    # Add subparser for the match sub-command
    #
    subparsers_m = parser_m.add_subparsers (title='Available Commands',
                                           description='Valid commands',
                                           help='Additional help')

    mastr = "Allocate the best matching resources if found"
    msstr = "Allocate the best matching resources if found. "\
            "If not found, check jobspec's overall satisfiability"
    mrstr = "Allocate the best matching resources if found. "\
            "If not found, reserve them instead at earliest time"
    parser_ma = subparsers_m.add_parser ('allocate', help=mastr)
    parser_ms = subparsers_m.add_parser ('allocate_with_satisfiability',
                                          help=msstr)
    parser_mr = subparsers_m.add_parser ('allocate_orelse_reserve', help=mrstr)

    #
    # Positional argument for info sub-command
    #
    parser_i.add_argument ('jobid', metavar='Jobid', type=int, help='Jobid')
    parser_i.set_defaults (func=info_action)

    #
    # Action for stat sub-command
    #
    parser_s.set_defaults (func=stat_action)

    #
    # Positional argument for cancel sub-command
    #
    parser_c.add_argument ('jobid', metavar='Jobid', type=int, help='Jobid')
    parser_c.set_defaults (func=cancel_action)

    #
    # Positional argument for match allocate sub-command
    #
    parser_ma.add_argument ('jobspec', metavar='Jobspec', type=str,
                            help='Jobspec file name')
    parser_ma.set_defaults (func=match_alloc_action)

    #
    # Positional argument for match allocate_with_satisfiability sub-command
    #
    parser_ms.add_argument ('jobspec', metavar='Jobspec', type=str,
                            help='Jobspec file name')
    parser_ms.set_defaults (func=match_alloc_sat_action)

    #
    # Positional argument for match allocate_orelse_reserve sub-command
    #
    parser_mr.add_argument ('jobspec', metavar='Jobspec', type=str,
                            help='Jobspec file name')
    parser_mr.set_defaults (func=match_reserve_action)

    #
    # Parse the args and call an action routine as part of that
    #
    try:
        args = parser.parse_args ()
        args.func (args)

    except IOError as e:
        print "I/O error({0}): {1}".format (e.errno, e.strerror)
        exit (3)

    except EnvironmentError as e:
        print "Environment error({0}): {1}".format (e.errno, e.strerror)
        if e.errno == errno.EBUSY:  # resource currently unavailable
            exit (16)
        if e.errno == errno.ENODEV: # unsatisfiable jobspec
            exit (19)
        else:
            exit (1)

    except yaml.YAMLError as e:
        print "Parsing error: ", e
        exit (2)

if __name__ == "__main__":
    main ()

#
# vi:tabstop=4 shiftwidth=4 expandtab
#
